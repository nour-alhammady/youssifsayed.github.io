في [الدّرس السابق](https://goo.gl/O2lwSk) تحدثنا عن TypeScript وبعض الاختلافات بينها وبيْن JavaScript والقليل عن مواصفة ES. في هذا الدّرس سنتحدث عمليًّا عن الأنواع في TypeScript، والمتغيرات والثوابت ومجالهما في ES6؛ أي المقال سيكون مفيدًا لمبرمجي JavaScript عدًا بعض الجزء الأول الذي يتحدث عن الأنواع.
##الأنواع في TypeScript
###ما هي الأنواع ببساطة
وبدون أي مصطلحات معقدة. في الطبيعة يوجد مواد سائلة، غازية، وصلبة، عندنا معشر المبرمجين يعادلها الأرقام والسلاسل النصية(string)، والمصفوفات(arrays) …، تعمل الأنواع على تنظيم عمل الوحدات وتوجيه عمل الخوارزميات …؛ البقرة تأكل الخضرة لتخرج لبنًا، التابع ToString() يأكل الأرقام ليخرج سلاسل نصية :)
أبسط الأنواع الأساسية في TypeScript:
###الأنواع المنطقية(boolean)
أبسط الأنواع وأهمها، هذا النوع من البيانات أما أن يكون صوابًا(true) أو خطأً(false) -أيضًا يُسميا صحيحًا/فاسدًا، إثباتًا/نفيًّا، موجبًا/سالبًا، 0/1 على حسب السياق-، يُعَدُّ هذا نوعًا أساسيًّا في أغلب لغات البرمجة وبدونه ستنفذ الخوارزميات في مسار وأحد; أي لن توجد العبارات الشرطية. مثال تعريف متغيرين منطقيين أحدهما صوابًا والآخر خطأً:

```typescript
	var Ok: boolean = true;
	var No: boolean = false;
```
###الأعداد(numbers)
تدعم JavaScript ES6، TypeScript كلًا من نظام العد العشري، الثنائي، والستة عشري والثماني:

 ```typescript
// نظام العد العشري
var TeenDecimal: number = 10; // النظام الافتراضي لا تحتاج كتابة شيء لاستخدامه؛ فقط رقم.

// نظام العد الثنائي
var TeenBinary: number  = 0b1010; // ES6, استخدم البادئة 0b لتعريف عدد ثنائي باستخدام البت.

// نظام العد الثماني
var TeenOctalES6: number = 0o12; // استخدم البادئة o12 لمواصفةES6 وينصح بها في حالة TypeScript؛ لكي تترجم في الشيفرة إلى عشري.
// var TeenOctal: number = 012; في حالة ES3 فقط، ولا ينصح بها؛ يخرج مجمع TypeScript خطأً إن استخدمتها ولم يكن إصدار مواصفة ES الهدف 3.  

// نظام العد الست عشري
var TeenHex: number = 0xa; // استخدم البادئة "0x" قبل العدد.
```
لا يوجد أي اختلاف بيْن عدد معرف بنظام ونظام آخر فيمكن مثلًا الجمع بين عددًا عُرِفَ بالثنائي وآخر بالعشري. 
ملاحظة: تدعم JavaScript, TypeScript الكتابة العلمية للأرقام بحيث يكتب العدد وأس العدد عشرة الذي سيضرب به، بين الحرف e، مثلًا الرقم مليون سيكتب هكذا:

	var M: number = 1e6;
###السلاسل النصية(string)
السلاسل النصية في JavaScript عبارة عن سلسلة من أحرف اليُونِكُود(Unicode) -UTF-16 على الأرجح- أي أنها لا تعتمد على البايت.
####البت والبايت والحرف!
نعلم جميعًا أنَّ الحاسوب يحفظ البيانات على هيئة مجموعة من الأرقام 0 أو 1 -تسمى البت(Bit)، ولدينا نوعًا آخر من الوحدات وهو البايت(Byte)، في أغلب الأنظمة -إن لم يكن كلها- يحوي ثمانية بت، أي أنَّ البايت الواحد يبدأ من 00000000 إلى 11111111 بالنظام الثنائي -من 0 إلى 255 بالعشري، إذًا لدينا 256 فرصة لحفظ الأحرف، هذا يفسر أنَّ الكثير من التراميز -التراميز التي تعتمد على بايت وأحد لكل حرف، لا يمكن أن يحفظ بها إلا 256 من الأحرف، كمثال ترميز [windows-1256](https://ar.wikipedia.org/wiki/ويندوز-1256)  أول 7 بت -من 0 إلى 127 بالعشري- تحفظ الرموز الأساسية والحروف اللاتينية([الأسكي](https://ar.wikipedia.org/wiki/%D8%A3%D8%B3%D9%83%D9%8A)) ومن 128 إلى 255 حروفًا ورموز عربية واللغات الشبيهة الأردو، الفارسية … 
إذًا لدينا مشكلة كيف سنحفظ أكثر من لغة في ملف وأحد، لا يكون ذلك بالاعتماد على البايت، بل باستخدام البت؛ لذلك سنتعرف على مجموعة جديد من التراميز تسمى Unicode، الصفحة التي بين يدك الآن تعتمد على إحداها [UTF-8](https://en.wikipedia.org/wiki/UTF-8) -إن لم أغيره لاحقًا :)، الحرف الواحد يحوي بين واحد إلى أربعة بايت -أو ستة بايت في الUTF-8 المعدل؛ لذا في لغات برمجيّة أخرى تعتمد على البايت في السلاسل النصية كلغة PHP يكون طول سلسلة نصية مكونة من حرف وأحد عربي بترميز UTF-8 إثنين، بينما في JavaScript وبالطبع TypeScript طوله وأحد. 
مثال على تعريف نص:

```typescript
	var str: string = “نص عربي";
```
ملاحظة: يمكن تعريف النص بين علامة الاقتباس المنفردة ' والمزدوجة " ولا يوجد فرق بينهما، وفي مواصفة ES6 أضيف دعم علامة الاقتباس ` تقدم ميزة جديدة(القوالب)، بحيث يمكن وضع متغيرات بالنص عبر كتابها في أقواس بعد علامة الدولار ${} مثال:

```typescript
	var count: number = 23;
	var message: string = `count is ${count}`; // count is 23
```
في مواصفة ES5 وما قبلها كنا سنستخدم معامل الجمع وهذا كابوس حقًا!. لولا ضيق المقام لكنت تحدثت عن محرف الخلوص(هكذا ترجمت Escape character)، وبعض معاملات النصوص لكني قررت كتابتها في الموضوع القادم بإذن الله.
###النوع Any
لا يمكن دائمًا معرفة النوع الذي سيحفظ في المتغير، أو قد تريد حفظ أكثر من نوع على متغير واحد لذا TypeScript تقدم النوع any، جرب ترجمة الشيفرة التالية مع تغيير any إلى string -سيظهر خطأ:

```typescript
	var notTyped: any = “string”;
	notTyped = 32;
```
###المصفوفات(Arrays)
من أحد الطرق المهمة لحفظ البيانات المصفوفة، وتتكون من سلسلة من البيانات المرتبة بشكل متتالي، ستجد قائمة في أعلى المدونة هذه القائمة قبل أن تحول إلى شيفرة HTML كانت عبارة عن سلسلة من الروابط -مصفوفة. وأبسط أشكال المصفوفة مصفوفة الصف؛ تتكون من صف وأحد من البيانات أي أن موقع العناصر من 0 إلى حجم المصفوفة بشكل مسطح، المصفوفات في TypeScript يجب أن تكون محددة النوع مصفوفة منطقية، رقمية، وتضع عناصر المصفوفة بداخل القوس []، مثال على مصفوفة سلاسل نصية:

```typescript
	var strArr: string[] = ["AB", "CD"];	
```
إذًا يمكن الوصول إلى العنصر الثاني من الموقع 1 -لاحظ العد يبدأ من الصفر:

```typescript
	var str = strArr[1];
```
ملاحظات:
1. لم نكتب نوع المُتغير بعد اسمه في التعريف؛ لأنه سيحدد تلقائيًّا من قبل المفسر قبل التجميع، كذا جميع الأمثلة السابقة كان من أجل التعلم والأمثلة فقط.
2. في حالة ما كانت المصفوفة ستحوي على أنواع مختلف استخدم النوع any سيكون نوع المصفوفة هكذا any[].
ويمكن أيضًا أن تكون مصفوفة الصف محددة الأعمدة عبر كتابة أنواع الأعمدة في الصف بين القوسين []، مثال على مصفوفة عمود تحوي كل الأنواع التي تعرفناها:

```typescript
	var typesArray: [boolean, number, string] = [true, 32, "abc"];
	
	var bool = typesArray[0];
	var num = typesArray[1];
	var str = typesArray[2];
```
بإذن الله في درس لاحق سنتحدث عن أنواع أخرى من المصفوفات وبعض العمليات عليها.
###الأنواع المتعددة(Enumeration)
هذا النوع تنفرد به TypeScript عن JavaScript -حتى الآن، حتى نفهمه ببساطة تخيل أن لدينا علبة ألوان تحوي الأبيض، والأحمر، والأخضر؛ إذًا كل من هذه الأنواع نوعًا مُنفصلًا يجمعهم أنهم جميعهم ألوان، الإعلان عن هذه الألوان بإستخدم TypeScript(نبدأ بالمفتاح enum ثم النوع الأب، ونفتح قوسًا ونكتب بعض الأنواع ونفصل بينها باستخدام الفاصلة اللاتينية):

```typescript
	enum Colors {
		White,
		Red,
		Green
	}
	
	// مثال على استخدام الأنواع
	var MyColor: Colors = Colors.White; // 0
	MyColor = Colors.Green; // 1
``` 
ملاحظات:
1. سنتعرف فيما بعد على البرمجة الكائنيّة إلى ذلك الوقت، فإن الوصول إلى أحد التوابع لكائن ما يكون عبر النقطة(.) كما وصلنا إلى أبناء Colors اللذان هما White, Green.
2. افتراضيًّا في الأنواع المُعددة يُحدد الأنواع (الأبناء) على حسب قيمة السابق + 1، والأول يُحدد صفرًا، White حدد إلى 0، Red إلى 1 …، مثلًا يُمكننا تحديد قيمة الأنواع بعض الأنواع هكذا:

```typescript
	enum Colors {
		White = 42,
		Red, // سيحدد إلى White+1 = 43
		Green = 53
	}
```
على الجانب: النوع الأب هو أيضًا مصفوفة لأسماء الأنواع التابعة:

```typescript
	enum Colors {
		White = 42,
		Red, // سيحدد إلى White+1 = 43
		Green = 53
	}

	var name1 = Colors[0]; // White
	var name3 = Colors[2]; // Green
```
###الأنواع الخاصة
تقدم TypeScript ميزة الإعلان عن أنواع خاصة، من أحد فوائدها تنظيم الشيفرة فمثلًا إن كنا سنحفظ المستخدمين باستخدام مصفوفة، وكان هذا العمل سيتم بين عدّة وظائف فمن الأفضل الإعلان عن نوعًا خاصًا يحدد كيف سيحفظ المستخدم، (يُعلن النوع باستخدام المُفتاح type باستخدام الأنواع الأساسية)، مثال على حفظ اسم وعمر المستخدم في مصفوفة صفيّة:

```typescript
    // الاسم والسن للمستخدم في مصفوفة صفية
    type user = [string, number];  

    var Ahmed: user = ["Ahmed", 42]
```
هكذا سنضمن تراسل بيانات المستخدمين بالشكل المطلوب بين الوظائف المختلفة، لنا عودة أخرى -بإذن الله- مع الأنواع الخاصة في درس لاحق سأعد له عن الأوجه(Interfaces). 
##المُتغيرات في TypeScript
بعدما تعرفنا على بعض الأنواع الأساسية في TypeScript، سنتعرف على المتغيرات، ربما وضح لك عملها من الأمثلة البرمجيّة السابقة، يُمكننا توضيحها بمثال بسيط كم الساعة الآن -أثناء كتابتي لهذا الجزء كانت الثانية :)- حسنًا هل الساعة ثابتة مقدارًا؟ لا، لنفترض أنَّ الساعة محفوظة في المُتغير time يمكننا الوصول إلى هذا المُتغير والتعديل علي مقداره، إذًا المُتغير هو عنوان في الذاكرة يقبل القراءة والتعديل عليه. في TypeScript قيمة المُتغير مقيدة بنوعه؛ مثلًا إن كان النوع الذي تم تعريف المتغير إليه رقمًا فلا يمكن جعل قيمته سلسلة نصية بعكس JavaScript؛ ومع ذلك يمكن استخدام النوع any.
 ###مجالان للمتغيرات وlet، var
انطلاقًا من ES6 أُضيف مفتاحًا جديدًا لتعريف المُتغيرات let، الفرق بين var و let ليس جوهريًّا كل الفرق في المجال(scope)، مجال المُتغير هو الجزء أو المساحة التي يمكن الوصول إلى المُتغير منها؛ في المُفتاح var المُتغير مجاله عامًا في جميع حدود الوظيفة -أعرف أننا لم نتحدث عن الدوال والوظائف بعد آسف، بينما مجال المُتغير المُعرف بالمفتاح let يكون عمومي في التعبير(ببساطة بداخل القوسين {})، مثال إيضاحي -لا تقلق سنشرح كل هذا فيما بعد:

```typescript
	var globalvar = "مُتغير عام";
	let globallet = "مُتغير عام أيضًا";

	// وظيفة، دالة
	function fun() {
		var globalvar2 = globalvar2; // var يكون عام في كل الوظيفة
		var globallet2 = globallet; // كذلك let
		
		// عبارة شرطية لو 1 يساوي 1
		if (1 == 1) {
			var var3 = globalvar2;
			let let3 = globallet2;
		}
		
		globalvar2 = var3; // يُمكن الوصول إلى var3 الذي عرف بداخل العبارة الشرطية
		
		// ---- خطأ ----
		globallet2 = let3; // خطأ لا يمكن الوصول إلى المُتغير let3 لأنه عرف باستخدام المفتاح let بداخل عبارة شرطية
	}

	// ---- خطأ --- 
	globalvar = globalvar2; // لا يمكن الوصول إلى المُتغير globalvar2 لأنّ حدوده الوظيفة
``` 
استبقنا الأحداث المجالات، الوظائف، التعبيرات … بدون أن نتحدث عن قواعد الإعلان عن مُتغير،
###قواعد الإعلان عن متغير:
قاعدة بنية(Syntax) الإعلان عن متغير في مواصفة ES:

	let|var var1 [= value1] [, var2 [= value2]] [, ..., varN [= valueN]];
ملاحظة: في TypeScript يوجد تعديل بسيط أنّ النوع يُمكن أن يلحق اسم المُتغير بعد  العلامة “:” (اختياري).
من هذا البنية يُمكننا استخلاص هذه القواعد:
1. لا فرق في بنية الإعلان عن مُتغير باستخدام المفتاح var أو let:
كما ذكرنا سابقًا كل الفرق في المجال.
2. يمكن الإعلان عن مُتغير بدون قيمته:
وفي TypeScript إن أُعلن عن مُتغير بدون نوع أو قيمة، فسيكون نوعه any، وقيمته undefined(غير مُحددة):

```typescript
	var test;
	test = "string";
	test = 32;
```
بينما إن لم يحدد نوعه وحددت قيمته في بنية الإعلان، فسيحدد إلى نوعًا تلقائيًّا -نوع القيمة المُحددة أظن أني كتبت هذا في أعلى المقال:).
3. يُمكن الإعلان عن أكثر من مُتغير باستخدام الفاصلة اللاتينية "," 
تعريف عدّة مُتغيرات مع إسناد كل مُتغير إلى نوع وقيمة مُختلفة:

```typescript
	var var1: string = "abc",
		var2/*: number لسنا بحاجة إلى كتابه سيّعين تلقائيًّا */ = 32,
		var3 = true;
```
##الثوابت
إن وصلت إلى هذا الجزء فستكون بحمد الله استطعت استحمال -الذي لا استحمله شخصيًّا :)، انطلاقًا من ES6 أضيفت الثوابت وهي كالمتغيرات لكنها للقراءة فقط أي لا يمكن التعديل عليها ما إن تعرف، مثلًا في الطبيعة يوجد ثابت الجذب العالم في الفيزياء (G)، عدد أيام الأسبوع، عدد ساعات اليوم …، بماذا تفيد الثوابت؟ من السابق يتضح أنّ لا فرق عمليّا بين مُتغير وثابت؛ ففي النهاية ما يُمكن القيام به بثابت يُمكن القيام به بمتغير، إلا أنه من الممارسات الجيّدة الإعلان عن القيّم الثابتة باستخدام الثواب؛ لأنها ببساطة ثوابت؛ مثلًا لا تعرف قيمة PI(ثابت الدائرة) كمتغير، أو كانت تلك القيم لا يجب أن تتغير كتعريف أكبر عدد للمستخدمين يتحمله البرنامج كمُتغير سيكون خطأً، أيضًا لجعل الشيفرة أكثر قابلية للقرأة من مطورين آخرين.
تعريف الثوابت كالمُتغيرات، فقط الاختلاف في المفتاح؛ في الثوابت المفتاح هو(const)، مثال على تعريف بعض الثوابت:

```typescript
	const PI = 22/7,
		  G = 6.67408e-11;

	var circlePerimeter = 2 * PI * 23;

	// خطأ
	PI = 32;
```
أحييك لوصولك إلى آخر المقال بدون أن تغلق الصفحة :)، هكذا نكون انتهينا من درسنا لليوم، بإذن الله الدرس القادم سيكون عن العاملات. أتمنى أن ترشدني إلى أي خطأ في المقال، أي ملاحظات تجعلني أحسن من جودة مقالاتي شكرًا.